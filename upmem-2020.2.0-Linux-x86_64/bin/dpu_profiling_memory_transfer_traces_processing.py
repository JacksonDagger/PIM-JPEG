# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
from collections import namedtuple
from dpu_profiling_parser_result import Duration

import os
import sys
import argparse
import importlib

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

TransferInfo = namedtuple('TransferInfo', 'start_ns end_ns size rank_path func_name')

rank_path = {}

# WRAM
wram_enter_nsecs = {}
wram_enter_secs = {}

wram_write_pid = {}
wram_read_pid = {}

wram_write_infos = {}
wram_read_infos = {}

wram_write_nb_per_pid = {}
wram_read_nb_per_pid = {}

# MRAM
mram_enter_nsecs = {}
mram_enter_secs = {}
mram_xfer_size = {}

mram_read_infos = {}
mram_write_infos = {}

mram_write_pid = {}
mram_read_pid = {}
mram_write_nb_per_pid = {}
mram_read_nb_per_pid = {}

# IRAM
iram_enter_nsecs = {}
iram_enter_secs = {}

iram_write_pid = {}
iram_read_pid = {}

iram_write_infos = {}
iram_read_infos = {}

iram_write_nb_per_pid = {}
iram_read_nb_per_pid = {}

# infos are stored per pid, linearize them.
def aggregate_infos(infos):
        infos_aggregate = []
        for pid, infos_dict in infos.items():
            for nb_xfer, xfer_info in infos_dict.items():
                infos_aggregate.append(xfer_info)

        return infos_aggregate

def trace_begin():
        module_results_parser.parse_init()

def trace_end():
        module_results_parser.parse_wram_write(aggregate_infos(wram_write_infos))
        module_results_parser.parse_wram_read(aggregate_infos(wram_read_infos))
        module_results_parser.parse_mram_write(aggregate_infos(mram_write_infos))
        module_results_parser.parse_mram_read(aggregate_infos(mram_read_infos))
        module_results_parser.parse_iram_write(aggregate_infos(iram_write_infos))
        module_results_parser.parse_iram_read(aggregate_infos(iram_read_infos))

        module_results_parser.parse_end()

def probe_libdpu__dpu_copy_to_wram_for_dpu_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_write_pid

                size = wram_write_pid[common_pid][0]
                path = rank_path[wram_write_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(wram_enter_secs[common_pid], wram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = wram_write_nb_per_pid.get(common_pid, 0)

                if common_pid not in wram_write_infos:
                    wram_write_infos[common_pid] = {}

                wram_write_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_to_wram_for_dpu")

                wram_write_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_to_wram_for_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, wram_word_offset, nb_of_words, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_write_pid

                wram_enter_nsecs[common_pid] = common_nsecs
                wram_enter_secs[common_pid] = common_secs

                wram_write_pid[common_pid] = tuple((nb_of_words * 4, rank))

def probe_libdpu__dpu_copy_from_wram_for_dpu_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_write_pid
                global wram_read_nb_per_pid

                size = wram_read_pid[common_pid][0]
                path = rank_path[wram_read_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(wram_enter_secs[common_pid], wram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = wram_read_nb_per_pid.get(common_pid, 0)

                if common_pid not in wram_read_infos:
                    wram_read_infos[common_pid] = {}

                wram_read_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_from_wram_for_dpu")

                wram_read_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_from_wram_for_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, wram_word_offset, nb_of_words, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_read_pid

                wram_enter_nsecs[common_pid] = common_nsecs
                wram_enter_secs[common_pid] = common_secs

                wram_read_pid[common_pid] = tuple((nb_of_words * 4, rank))

def probe_libdpu__dpu_copy_to_wram_for_rank_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_write_pid

                size = wram_write_pid[common_pid][0]
                path = rank_path[wram_write_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(wram_enter_secs[common_pid], wram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = wram_write_nb_per_pid.get(common_pid, 0)

                if common_pid not in wram_write_infos:
                    wram_write_infos[common_pid] = {}

                wram_write_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_to_wram_for_rank")

                wram_write_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_to_wram_for_rank(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, wram_word_offset, nb_of_words, perf_sample_dict):
                global wram_enter_nsecs, wram_enter_secs
                global wram_write_pid

                wram_enter_nsecs[common_pid] = common_nsecs
                wram_enter_secs[common_pid] = common_secs

                wram_write_pid[common_pid] = tuple((nb_of_words * 4 * 64, rank))

def probe_libdpu__dpu_transfer_matrix_add_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, dpu, transfer_matrix, size, offset_in_mram, perf_sample_dict):
                global mram_xfer_size

                if (transfer_matrix not in mram_xfer_size):
                    mram_xfer_size[transfer_matrix] = {}
                mram_xfer_size[transfer_matrix][dpu] = size

def probe_libdpu__dpu_transfer_matrix_clear_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, dpu, transfer_matrix, perf_sample_dict):
                global mram_xfer_size

                del(mram_xfer_size[transfer_matrix][dpu])

def probe_libdpu__dpu_transfer_matrix_clear_all(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, transfer_matrix, perf_sample_dict):
                global mram_xfer_size

                for dpu in mram_xfer_size[transfer_matrix]:
                    del(mram_xfer_size[transfer_matrix][dpu])

def probe_libdpu__dpu_transfer_matrix_free(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, transfer_matrix, perf_sample_dict):
                global mram_xfer_size

                del(mram_xfer_size[transfer_matrix])

def probe_libdpuhw__log_rank_path(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, path, perf_sample_dict):
                global rank_path

                rank_path[rank] = path

def probe_libdpu__dpu_copy_to_mrams(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, transfer_matrix, perf_sample_dict):
                global mram_enter_secs, mram_enter_nsecs
                global mram_write_pid

                if (common_pid not in mram_enter_secs):
                    mram_enter_secs[common_pid] = {}
                    mram_enter_nsecs[common_pid] = {}

                mram_enter_secs[common_pid][transfer_matrix] = common_secs
                mram_enter_nsecs[common_pid][transfer_matrix] = common_nsecs

                mram_write_pid[common_pid] = tuple((transfer_matrix, rank))

def probe_libdpu__dpu_copy_to_mrams_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global mram_xfer_size
                global mram_enter_secs, mram_enter_nsecs
                global mram_write_infos
                global mram_write_pid
                global mram_write_nb_per_pid
                global rank_path

                transfer_matrix = mram_write_pid[common_pid][0]
                path = rank_path[mram_write_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(mram_enter_secs[common_pid][transfer_matrix],
                                                mram_enter_nsecs[common_pid][transfer_matrix])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = mram_write_nb_per_pid.get(common_pid, 0)

                xfer_size = 0
                nb_dpus = 0
                for dpu, size in mram_xfer_size[transfer_matrix].items():
                    xfer_size += size
                    nb_dpus += 1

                if common_pid not in mram_write_infos:
                    mram_write_infos[common_pid] = {}

                mram_write_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, xfer_size, path, "dpu_copy_to_mrams_{}dpus".format(nb_dpus))

                mram_write_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_from_mrams(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, transfer_matrix, perf_sample_dict):
                global mram_enter_secs, mram_enter_nsecs
                global mram_read_pid

                if (common_pid not in mram_enter_secs):
                    mram_enter_secs[common_pid] = {}
                    mram_enter_nsecs[common_pid] = {}

                mram_enter_secs[common_pid][transfer_matrix] = common_secs
                mram_enter_nsecs[common_pid][transfer_matrix] = common_nsecs

                mram_read_pid[common_pid] = tuple((transfer_matrix, rank))

def probe_libdpu__dpu_copy_from_mrams_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global mram_xfer_size
                global mram_enter_secs, mram_enter_nsecs
                global mram_read_infos
                global mram_read_pid
                global mram_read_nb_per_pid
                global rank_path

                transfer_matrix = mram_read_pid[common_pid][0]
                path = rank_path[mram_read_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(mram_enter_secs[common_pid][transfer_matrix],
                                                mram_enter_nsecs[common_pid][transfer_matrix])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = mram_read_nb_per_pid.get(common_pid, 0)

                xfer_size = 0
                nb_dpus = 0
                for dpu, size in mram_xfer_size[transfer_matrix].items():
                    xfer_size += size
                    nb_dpus += 1

                if common_pid not in mram_read_infos:
                    mram_read_infos[common_pid] = {}

                mram_read_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, xfer_size, path, "dpu_copy_from_mrams_{}dpus".format(nb_dpus))

                mram_read_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_to_iram_for_dpu_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_write_pid

                size = iram_write_pid[common_pid][0]
                path = rank_path[iram_write_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(iram_enter_secs[common_pid], iram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = iram_write_nb_per_pid.get(common_pid, 0)

                if common_pid not in iram_write_infos:
                    iram_write_infos[common_pid] = {}

                iram_write_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_to_iram_for_dpu")

                iram_write_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_to_iram_for_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, iram_instruction_index, nb_of_instructions, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_write_pid

                iram_enter_nsecs[common_pid] = common_nsecs
                iram_enter_secs[common_pid] = common_secs

                iram_write_pid[common_pid] = tuple((nb_of_instructions, rank))

def probe_libdpu__dpu_copy_to_iram_for_rank_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_write_pid

                size = iram_write_pid[common_pid][0]
                path = rank_path[iram_write_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(iram_enter_secs[common_pid], iram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = iram_write_nb_per_pid.get(common_pid, 0)

                if common_pid not in iram_write_infos:
                    iram_write_infos[common_pid] = {}

                iram_write_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_to_iram_for_rank")

                iram_write_nb_per_pid[common_pid] = cur_transfer + 1

def probe_libdpu__dpu_copy_to_iram_for_rank(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, iram_instruction_index, nb_of_instructions, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_write_pid

                iram_enter_nsecs[common_pid] = common_nsecs
                iram_enter_secs[common_pid] = common_secs

                iram_write_pid[common_pid] = tuple((nb_of_instructions * 64, rank))

def probe_libdpu__dpu_copy_from_iram_for_dpu(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_ip, rank, iram_instruction_index, nb_of_instructions, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_read_pid

                iram_enter_nsecs[common_pid] = common_nsecs
                iram_enter_secs[common_pid] = common_secs

                iram_read_pid[common_pid] = tuple((nb_of_instructions, rank))

def probe_libdpu__dpu_copy_from_iram_for_dpu_exit__return(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        common_callchain, __probe_func, __probe_ret_ip, perf_sample_dict):
                global iram_enter_nsecs, iram_enter_secs
                global iram_write_pid
                global iram_read_nb_per_pid

                size = iram_read_pid[common_pid][0]
                path = rank_path[iram_read_pid[common_pid][1]]
                start_ns = Duration.nanoseconds(iram_enter_secs[common_pid], iram_enter_nsecs[common_pid])
                end_ns = Duration.nanoseconds(common_secs, common_nsecs)

                cur_transfer = iram_read_nb_per_pid.get(common_pid, 0)

                if common_pid not in iram_read_infos:
                    iram_read_infos[common_pid] = {}

                iram_read_infos[common_pid][cur_transfer] = TransferInfo(start_ns, end_ns, size, path, "dpu_copy_from_iram_for_dpu")

                iram_read_nb_per_pid[common_pid] = cur_transfer + 1

def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
                print(get_dict_as_string(event_fields_dict))
                print('Sample: {'+get_dict_as_string(perf_sample_dict['sample'], ', ')+'}')

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print("%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm), end="")

def get_dict_as_string(a_dict, delimiter=' '):
        return delimiter.join(['%s=%s'%(k,str(v))for k,v in sorted(a_dict.items())])


parser = argparse.ArgumentParser(description = 'Raw profiling results')
parser.add_argument('--result-parser', default = "dpu_profiling_print_summary",
                help = 'Path to python result parser script')
args = parser.parse_args()

module_results_parser = importlib.import_module(args.result_parser)
